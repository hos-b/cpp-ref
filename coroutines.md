# Coroutines ([Part 1](README.md)), ([Part 2](modern.md))
given the impossible "user" API, it needs a separate file.
C++ implements the _stackless_ coroutine: when suspended, control is returned to the immediate caller. props to Andreas Weis for his cppcon talk.

# 0. Examples

## 0.1. async computation
the most basic way to do this is to use blocking calls:
```cpp
auto [ec, bytes_read] = read(socket, buffer);
```
to improve the performance, one might use an async library:
```cpp
async_read(socket, buffer, [](std::error_code ec, std::size_t bytes_read) {
    // ...
})
```
there is an inversion of the control flow and the parameters. the caller calls some function and gets values back in the blocking case. in the async case, the library runs a callback function which takes as arguements the expected return values.

coroutines allow us to change the async code s.t. it looks like the blocking case:
```cpp
auto [ec, bytes_read] = co_await async_read(socket, buffer);
```
this will pause the current coroutine (the keywords are only callable within coroutines), the control is given to the `async_read`. as soon as the data becomes available, the current coroutine is woken up and the execution continues.

## 0.2. suspend/resume
lazy computation:
```cpp
MyCoroutine co = start_computation(initial_data);
auto some_results = co.provide(some_data);
auto more_results = co.provide(more_data);
auto final_results = co.results;
```

## 0.3. basic example: fibonacci
the normal implementation has a flaw:
```cpp
std::vector<int> fibo(int n);
```
it needs to keep all `n` elements in the memory. in general, if we have a slow computation which processes the numbers one by one, we would have to pay for the storage of all numbers. dealing with infinite ranges is also hard.

the previous solutions to these problems were factories:
```cpp
struct FiboGenerator
{
    int next();
private:
    some_sort_of_state;
};
...
// returns a FiboGenerator object that will
// start from the first fibonacci number.
FiboGenerator make_fibo_gen();
```
from the outside coroutines are indistinguishable from such functions. we only have their interface. 
coroutines should be thought of as factory functions that is producing the actual coroutine.

# 1. Intro
the initial call to the coroutine object returns an object of `ReturnType`, and hand it back to the caller. the interface of `ReturnType` is going to determine what the coroutine can do. the end user will only ever need to understand and deal with this object.

a function is a coroutine if it has one of the following keywords:
- `co_return`
- `co_yield`
- `co_await`

as soon as the compiler detects this, it changes the rules of how the code inside the body works. reading it as a typical function will not make sense.

it would be great if the fibonacci coroutine could look something like:
```cpp
FiboGenerator make_fibo_gen() {
    int i1 = 1;
    int i2 = 1;
    while (;;) {
        co_yield i1;
        i1 = std::exchange(i2, i1 + i2);
    }
}
```

# 2. Barebones Coroutine

```cpp
ReturnType hello_coroutine() {
    co_return;
}

struct ReturnType
{
    struct promise_type{};
};
```
this doesn't actually compile yet, because the compiler needs a few functions to be defined by the `promise_type`.

## 2.1. promise_type
`std::future` and `std::promise` are part of the C++ threading library. future is what is handed out to the caller, so that it can retrieve the result. the future has the role of the `ReturnType` in coroutines.
we also need something that the callee can put the value in, which is the promise type for threads. the coroutine promise has a similar _idea_ behind it. this object remains inside the coroutine.

unlike the threading object pair, where the producer constructs the promise on its own, the coroutine promise is automatically generated by the compiler. it is the central intersection point for the coroutine code and the caller code. it determines what happens in the essential timepoints during a coroutine's lifetime, namely what happens at the startup and the completion of the coroutine and how various return values are handled, when the coroutine reaches the end of its control flow.

the compiler expects 5 functions to be inside the promise type:
```cpp
struct promise_type
{
    ReturnType get_return_object(); { return {}; }
    void return_void() {};
    void unhandled_exception() {};
    std::suspend_always initial_suspend() noexcept { return {}; }
    std::suspend_always final_suspend() noexcept { return {}; }
};
```
1. `get_return_object`: has the same return type as the coroutine body. when the coroutine starts executing, a compiler implicitly calls this function. it is now up to the `promise_type` to construct the return object that will be handed back to the caller (in the basic example, `FiboGenerator` would be constructed here).

we do not have direct access to where it is stored (compiler magic). when the coroutine reaches its first suspension point and the control flow is returned back to the caller, then the caller receives this object as the return value. _ithink_: this can be after the initial suspension or after the first `co_yield` or the final suspend in badly written coroutine.

2. `return_void`: decides what happens when we reach an empty `co_return` statement. there's also a corresponding `return_value` for when the `co_return` is used in conjunction with a value, but in our example, that is not done.

3. `unhandled_exception`: handles what happens when we exit the coroutine through an exception.

4. `initial_suspend`
5. `final_suspend`: these two are the customization points that allow us to execute some code, when the coroutine first starts executing (initial_suspend) and shortly before when the coroutine stops executing for good (final_suspend), e.g. if we return from the coroutine or the control flow falls off the end or if we exit via an exception.

`std::suspend_always` tells the compiler, that we always want to suspend at that particular point (intial, final) and hand the control flow back to the caller.
`std::suspend_never` lets the coroutine continue executing without relinquishing control.

the code can actually compile now:
```cpp
ReturnType hello_coroutine()
{
    std::println("Hello from coroutine");
    co_return;
}

int main() {
    hello_coroutine(); // prints nothing
    return 0;
}
```
if we change the `initial_suspend` declaration from `suspend_always` to `suspend_never`, then we see the message on the standard output.

## 2.2. pausing and awaitables
`Awaitable` is a type we can call `co_await` on and vice versa.
```cpp
AsyncRead awaitable = async_read(socket, buffer);
auto [ec, bytes_read] = co_await awaitable;
```
calling `co_await` is an opportunity for suspension. it is the only operator that explicitly lets us pause the coroutine and return control flow back to the caller. inital_suspend and final_suspend also hand control over, but are only implicitly usable.

the `Awaitable` controls whether we actually go into suspension and what gets exectued during. similar to how `promise_type` controls what happens during startup and returning, the `Awaitable` controls what happens whether and when we go in and out of suspension.
```cpp
struct Awaitable
{
    bool await_ready();
    void await_suspend(std::coroutine_handle<prmoise_type>);
    void await_resume();
};
```
1. `await_ready`: decides whether we go into suspension by returning a the readiness flag, i.e. `true` = the info is ready, do not suspend and do not call `await_resume()`.
2. `await_suspend`: executed shortly before we go into suspension. it takes as its argument the `coroutine_handle` of the coroutine that called the `co_await`. it's templated but can also be used without a type (`<>`), s.t. it can refer to any coroutine. if we use the specialization, it means that the awaitable can only be waited upon by coroutines that use a specific `promise_type`. it is possible that we would want to leave open what coroutines `co_await` on our `Awaitable`.
3. `await_resume`: this is the function that gets called **right before** the coroutine retakes the control.

### mind blown
`initial_suspend` and `final_suspend` actually return an `Awaitable`:
```cpp
struct std::suspend_always
{
    bool await_ready() { return false; }
    void await_suspend(std::coroutine_handle<>) {}
    void await_resume() {}
};
```
### coroutine_handle
defines what we can actually do inside `await_suspend`:
```cpp
template <typename promise_type>
struct std::coroutine_handle<promise_type>
{
    void resume() const;
    void destroy() const;
    promise_type& promise() const;
    static coroutine_handle<promise_type> from_promise(promise_type&);
}
```

1. `resume`: it resumes a **suspended** coroutine.
2. `destroy`: the second way of destroying the coroutine frame. the first way being that it runs to completion. note that `coroutine_handle` is not a smart pointer type, i.e. it won't destroy itself.

## 2.3. order of execution
```cpp
struct ReturnType / std::coroutine_traits<ReturnType, ...>
{
    struct promise_type
    {
        // start -->
        promise_type(T...); // optional
        ReturnType get_return_object();
        std::suspend_always initial_suspend();
        // <--
        // shutdown -->
        void return_value(T); / void return_void();
        void unhandled_exception();
        std::suspend_always final_suspend() noexcept;
        // <--
    };
};
```
we don't always need a nested typedef for the `promise_type`. we can instead specialize the `std::coroutine_traits` tempalted class to point out where the `promise_type` is. this also unlocks some new possibilities, like having a coroutine with `ReturnType = void`.

as soon as the compiler detects a coroutine, it will look at the return type, which in turn defines what the promise type is. the optional constructor is called by the compiler and the arguments passed when creating the coroutine (`T...`) are forwarded to this constructor. afterwards, the `get_return_object` will get called which constructs the object returned to the caller. the initial suspend is then called and after that the coroutine is started and the function body starts executing. simlarly during shutdown you can either `co_return` a value using `return_value` or fall off the end, which is the same as having an empty `co_return`, in which case the `return_void` will get called. you cannot do both. `unhandled_exception` is called when we exit with an exception instead of a return value. once the return has been processed, the `final_suspend` is invoked as the last thing before the coroutine is shut down. 

## 2.4. wake me up inside
back to the example, how do we make the coroutine start executing its body? 
```cpp
struct ReturnType
{
    struct promise_type
    {
        std::suspend_always initial_suspend() { return {}; }
        ...
    }
    ...
};

...

ReturnType hello_coroutine()
{
    std::println("Hello from coroutine");
    co_return;
}

int main() {
    ReturnType c = hello_coroutine(); // prints nothing
    return 0;
}
```

### through the return object
we know that resuming is only possible through the `std::coroutine_handle`. why not do?
```cpp
struct promise_type
{
    ReturnType get_return_object() {
        return ReturnType{
            std::coroutine_handle<promise_type>::from_promise(*this);
        };
    }
};

struct ReturnType
{
    std::coroutine_handle<promise_type> handle;
    ReturnType(std::coroutine_handle<promise_type> h) : handle(h) {}
    void resume() { handle.resume(); }
};
```
its easy but not mandatory, but must be done in some way so that all elements of the coroutine are connected:
```
             ┌────────┐                           ┌───────────┐
             │        │                           │           │
             │ Caller │                           │ coroutine ├─────────┐
             │        │                           │           │         |
             └────┬───┘                           └─────┬─────┘         |
                  │                                     │               |
                  │                                     │               |
                  │                                     │               |
            ┌─────▼──────┐                        ┌─────▼─────┐         |
            │            │                        │           │         |
  ┌ - - - - | ReturnType ├─────────┐              │ Awaitable │         |
  ❘         │            │         │              │           │         |
  ❘         └────────────┘         │              └─────┬─────┘         |
  ❘                          handle│                    │               |yield_value()
  ❘                                │                    │               |
  ❘get_return_object()             │                    │               |
  ❘                       ┌────────▼─────────┐          │               |
  ❘                   ┌───► coroutine_handle ◄──────────┘               |
  ❘                   │   └────────┬─────────┘  await_suspend()         |
  ❘                   │            │                                    |
  ❘   ::from_promise()│            │                                    |
  ❘                   │            │.promise()                          |
  ❘                   │            │                                    |
  ❘              ┌────┴────┐       │                                    |
  └ - - - - - - -│ promise ◄───────┴────────────────────────────────────┘
                 └─────────┘
```

## 2.5. getting data out of the coroutine
the user must be able to get something out of the coroutine, either through `co_yield` or `co_return`. the coroutine itself only has access to `Awaitable`s.
```cpp
Coroutine f1()
{
    ...
    co_await AwaitableAnswer{420};
}
AwaitableAnswer::AwaitableAnswer(int v) :
    value_(v) {}
```
now the data lives inside the `Awaitable`, but it must reach the coroutine:
```cpp
struct promise_type
{
    ...
    int value;
}
void AwaitableAnswer::await_suspend(std::coroutine_handle<promise_type> h)
{
    h.promise().value = value_;
}
```
and now the data lives inside the promise, i.e. the central intersection point. on the caller side, we can create an interface such as:
```cpp
struct Coroutine
{
    ...
    int getAnswer() { return handle.promise().value; }

};
int main()
{
    Coroutine c1 = f1();
    std::println("The answer is {}", c1.getAnswer());
}
```

## 2.6. getting data into the coroutine
the caller might want to put the coroutine to sleep at some point to provide some data to it.
```cpp
Coroutine f1()
{
    ...
    int some_data = co_await OutsideAnswer{};
}

int main()
{
    Coroutine c1 = f1();
    c1.provide(420);
}
```
the `co_await` call suspends the coroutine and return control back to main. the `provide` function from the `ReturnType` stores the provided data somewhere inside the `promise_type` and wakes the coroutine. 
```cpp
void Coroutine::provide(int value)
{
    handle.promise().value = value;
    handle.resume();
} 
```
compared to the previous approach where the data was ready at `await_suspend`, there is no direct access to the `promise_type` when the coroutine is resumed. that is why the handle must be saved when we are suspending the coroutine:
```cpp
struct OutsideAnswer
{
    bool await_ready() { return false; }
    void await_suspend(std::coroutine_handle<promise_type> h)
    {
        handle = h;
    }
    int await_resume()
    {
        return handle.promise().value;
    }

    std::coroutine_handle<promise_type> handle;
};
```
the `await_resume` function can have any return type. previously we had only used void because it was not a data providing Awaitable.

## 2.7. yield_value
we can now create the fibonacci generator:
```cpp
FiboGenerator makeFiboGenerator()
{
    int i1 = 1;
    int i2 = 1;
    while (;;)
    {
        co_await NewNumberAwaitable{i1};
        i1 = std::exchange(i2, i1 + i2);
    }
}
```
which looks ugly. we can make it look more readable by implementing an optional function inside our `promise_type`:
```cpp
NewNumberAwaitable yield_value(int i) {
    return NewNumberAwaitable{i};
}
```
which will let us use `co_yield i1`. is it necessary to create the new object if we're already inside the `promise_type`? nope:
```cpp
std::suspend_always prmoise_type::yield_value(int i)
{
    value = i;
    return {};
}
```
instead of defining and constructing an `Awaitable`, we save the value inside the promise right away.

## 2.8. symmetric transfer
when we call `co_await`, we return the control back to the caller. in our examples so far, this has been the main function, which when necessary resumed the coroutine through the `ReturnType`.

it is also possible to hand control over to another **suspended** coroutine. this is implemented in a way that the two coroutines switch places, i.e. the first one executes and then switches places with the second one on the callstack, instead of having both of them there. to do this, we need an `Awaitable` that returns the successor coroutine handle (instead of `void`) in its `await_suspend` function:

```cpp
struct promise_type
{
    ...
    std::coroutine_handle<promiset_type> other;
};
std::coroutine_handle<> Transfer::await_suspend(std::coroutine_handle<promise_type> me)
{
    return me.promise().other ? me.promise.other : me;
}

Coroutine f1()
{
    ...
    co_await Transfer{};
}
```
this would hand over control to the other coroutine if available, otherwise it wakes itself up. it has to wake itself up, because we explicitly wanted to wait on the other coroutine (using the `Transfer` awaitable), which is not available.

further reading: it is possible to have a `ReturnType` that is also an `Awaitable` (coroutine inside a coroutine?).

## 2.9. notes
* always use `std::suspend_always` for the `final_suspend` and destroy the coroutine through its handle. there is no clean way of actually checking whether the coroutine has been destroyed. if `destroy()` is not called, the only other way is for the control to fall off the coroutine body, which is not a reliable way of memory management, unless we use a smart pointer.
